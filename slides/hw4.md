# Домашнее задание № 4

Домашнее задание посвещено продвинутым фишкам PostgreSQL

## Служебные функции БД

Используя функцию определения размера таблицы, вывести top-5 самых больших таблиц базы.

В самой большой таблице определить самую тяжелую колонку.

## Специфические функции Postgres

Используя специальные фунцияи постгри, найдём пользователей с самыми похожими вкусами, на основе просмотренных фильмах.

1) Используя функцию array_agg собрать в массив все фильмы, просмотренные пользователем. 
При этом повторов в списке контента быть не должно.

2) Создайте таблицу user_movies_agg, в которую сохраните результат запроса

3) Используя следующий синтаксис, создайте функцию cross_arr оторая принимает на вход два массива arr1 и arr2. 
Функциия возвращает массив, который представляет собой пересечение контента из обоих списков.

CREATE OR REPLACE FUNCTION cross_arr (int[], int[]) RETURNS int[] language sql as $FUNCTION$ тело_функции ; $FUNCTION$;

тело_функции - это SQL запрос. В этом запросе нужно сделать INTERSECT между UNNEST(arr1) и UNNEST(arr2).

Примечание - по именам к аргументам обращаться не получится, придётся делать через $1 и $2.

Из результата INTESECT нужно снова сделать массив.

4) Сформируйте запрос следующего вида: достать из таблицы всевозможные наборы u1, r1, u2, r2.
u1 и u2 - это id пользователей
r1 и r2 - соответствующие массивы рейтингов

Тривиальных пар (где u1==u2) быть не должно. Результат запроса оформите как CTE.

Примените к CTE функцию cross_arr. Результат запроса - u1, u2, crossed_array - id двух пользователей и их общие фильмы.

Отсортируйте выборку по длине crossed_array и оставите топ-10 пользователей с самыми большими пересечениями.

Сформируйте рекомендации - для каждой пары посоветуйте для u1 контент, который видел u2, но не видел u1 (в виде массива).

Итоговая выборка:
u1 recs1
u2 recs2
u3 recs3
...
